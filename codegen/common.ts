
import { resolve } from 'path';
import { readdir, readFile } from 'fs/promises';
import { deepStrictEqual } from 'assert';

export type Mode = 'OCPP16' | 'OCPP20' | 'OCPP21';

/**
 * Codegen scripts need to slightly change their behavior depending on which
 * version of the OCPP protocol they are working with. This function ensures
 * that the provided string falls within the set of supported modes.
 */
const ensureMode = (mode: any): Mode => {
  switch (mode) {
    case 'OCPP16':
    case 'OCPP20':
    case 'OCPP21':
      return mode;
    default:
      throw new Error(`invalid mode ${mode}`);
  }
};

/**
 * Strips a JSON schema of anything that might anger or alter the behavior of
 * AJV and/or json-schema-to-typescript . 
 */
const cleanupSchema = (mode: Mode, schema_name: string, schema_defn: any, parent_schema: any) => {
  delete schema_defn.id;
  delete schema_defn.$id;
  delete schema_defn.$schema;
  delete schema_defn.comment;
  delete schema_defn.javaType;
  delete schema_defn.description;
};

/**
 * Fixes issues hardcoded into the official JSON schema packages released by 
 * the Open Charge Alliance as an attachment to the OCPP specifications.
 */
const applySchemaFixes = (mode: Mode, schema_name: string, schema_defn: any) => {
  // The official OCPP 1.6 schema files contain a mispelling of the unit of
  // measure "Celsius", which is spelled "Celcius". Thus we add the correct
  // spelling wherever needed.
  if (mode === 'OCPP16' && schema_name === 'StopTransactionRequest') {
    schema_defn.properties.transactionData.items.properties.sampledValue.items.properties.unit.enum.push('Celsius');
  }
};

/**
 * Deduplicates definitions of child schema and merges them into the single
 * dictionary of shared definitions passed as the `definitions` parameter.
 */
const cleanupAndDeduplicateDefinitions = (mode: Mode, schema_defn: any, definitions: Record<string, any>) => {
  if (schema_defn.definitions) {
    Object.entries(schema_defn.definitions).forEach(([child_schema_name, child_schema_defn]) => {
      cleanupSchema(mode, child_schema_name, child_schema_defn, schema_defn);
      if (child_schema_name in definitions) {
        deepStrictEqual(definitions[child_schema_name], child_schema_defn);
      } else {
        definitions[child_schema_name] = child_schema_defn;
      }
    });
    schema_defn.definitions = definitions;
  }
};

/**
 * Reads and pre-process schema files in the given directory.
 */
export const readSchemaFiles = async (mode: Mode, dir_abspath: string): Promise<{ schemas: Record<string, any>; definitions: Record<string, any>; }> => {
  const schemas: Record<string, any> = {};
  const definitions: Record<string, any> = {};
  for (const file_name of await readdir(dir_abspath)) {
    if (!file_name.endsWith('.json')) {
      continue;
    }
    let schema_name = file_name.slice(0, -5);
    if (mode === 'OCPP16' && !schema_name.endsWith('Response')) {
      // The names of schema files for CALL messages within the OCPP 1.6 spec
      // archive do not have the `Request` suffix.
      schema_name += 'Request';
    }
    if (!schema_name.match(/(?:Request|Response)$/)) {
      if (mode !== 'OCPP21' && schema_name !== 'NotifyPeriodicEventStream') {
        throw new Error(`invalid schema name ${schema_name}: does not end with either "Request" or "Response"`);
      }
    }
    const file_abspath = resolve(dir_abspath, file_name);
    const file_data = await readFile(file_abspath, 'utf8');
    const schema_defn = JSON.parse(file_data);
    cleanupSchema(mode, schema_name, schema_defn, null);
    applySchemaFixes(mode, schema_name, schema_defn);
    cleanupAndDeduplicateDefinitions(mode, schema_defn, definitions);
    schemas[schema_name] = schema_defn;
  }
  return { schemas, definitions };
};

/**
 * Models script params passed via CLI args.
 */
export interface CLIParams {
  input_dir_abspath: string;
  output_file_abspath: string;
  mode: Mode;
}

/**
 * Helper function that facilitates reading CLI args.
 */
export const readCLIParams = () => {
  const input_dir_path = process.argv[2];
  const input_dir_abspath = resolve(process.cwd(), input_dir_path);
  const output_file_path = process.argv[3];
  const output_file_abspath = resolve(process.cwd(), output_file_path);
  const mode = process.argv[4];
  return { input_dir_abspath, output_file_abspath, mode: ensureMode(mode) };
};

/**
 * Header added to files generated by codegen scripts.
 */
export const output_file_header = `/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NEVER BE EDITED DIRECTLY.
 * SEE ../../BUILD.md
 *
 * GENERATED ON: ${new Date().toISOString()}
 *
 */\n\n\n`;
