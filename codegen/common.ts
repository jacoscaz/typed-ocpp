
import { resolve } from 'path';
import { readdir, readFile } from 'fs/promises';

export type Mode = 'OCPP16' | 'OCPP20' | 'OCPP21';

export const ensureMode = (mode: any): Mode => {
  switch (mode) {
    case 'OCPP16':
    case 'OCPP20':
    case 'OCPP21':
      return mode;
    default:
      throw new Error(`invalid mode ${mode}`);
  }
};

export interface SchemaDescriptor<T extends {} = any> {
  name: string;
  schema: T;
}

export const readSchemaFiles = async function *(mode: Mode, dir_abspath: string): AsyncIterable<SchemaDescriptor> {
  for (const file_name of await readdir(dir_abspath)) {
    if (!file_name.endsWith('.json')) {
      continue;
    }

    let schema_name = file_name.slice(0, -5);
    if (mode === 'OCPP16') {
      if (!schema_name.match(/(?:Request|Response)$/)) {
        // The names of schema files for CALL messages within the OCPP 1.6 spec
        // archive do not have the `Request` suffix.
        schema_name += 'Request';
      }
    }
    const file_abspath = resolve(dir_abspath, file_name);
    const file_data = await readFile(file_abspath, 'utf8');
    // Ensure that the file's contents is actually valid JSON and cleanup 
    // keywords that break Ajv in strict mode.
    const schema = JSON.parse(file_data);
    yield { name: schema_name, schema };
  }
};

export interface CLIParams {
  input_dir_abspath: string;
  output_file_abspath: string;
  mode: Mode;
}

export const readCLIParams = () => {
  const input_dir_path = process.argv[2];
  const input_dir_abspath = resolve(process.cwd(), input_dir_path);
  const output_file_path = process.argv[3];
  const output_file_abspath = resolve(process.cwd(), output_file_path);
  const mode = process.argv[4];
  return { input_dir_abspath, output_file_abspath, mode: ensureMode(mode) };
};

export const output_file_header = `/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NEVER BE EDITED DIRECTLY.
 * SEE ../../BUILD.md
 *
 * GENERATED ON: ${new Date().toISOString()}
 *
 */\n\n\n`;
